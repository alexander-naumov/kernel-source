From e4a946acbf5d29bb3e6913b6eeeaea3a2ea74168 Mon Sep 17 00:00:00 2001
From: "Luis R. Rodriguez" <mcgrof@suse.com>
Date: Tue, 2 Jan 2018 12:23:20 -0800
Patch-mainline: never, kabi
References: kabi
Subject: [PATCH] xfs: address kabi for xfs buffer retry infrastructure

XFS had a design flaw for which we had to add significant
infrastructure to correct. The design flaw was having buffers
stuck and never retried upon certain types of failures, which
can also in turn block unmount. We wrap the new data structures
changes with __GENKSYMS__ so that only kernels booted with these
changes get the enhancements, this keeps compatibility with the
kernel headers in case SGI's clustered XFS solution relies on
these old data structures.

Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
---
diff --git a/fs/xfs/xfs_buf.h b/fs/xfs/xfs_buf.h
index 5ca07bcd1a80..0efbefcac8d7 100644
--- a/fs/xfs/xfs_buf.h
+++ b/fs/xfs/xfs_buf.h
@@ -187,6 +187,7 @@ typedef struct xfs_buf {
 	unsigned int		b_offset;	/* page offset in first page */
 	int			b_error;	/* error code on I/O */
 
+#ifndef __GENKSYMS__
 	/*
 	 * async write failure retry count. Initialised to zero on the first
 	 * failure, then when it exceeds the maximum configured without a
@@ -205,6 +206,7 @@ typedef struct xfs_buf {
 	int			b_retries;
 	unsigned long		b_first_retry_time; /* in jiffies */
 	int			b_last_error;
+#endif
 
 	const struct xfs_buf_ops	*b_ops;
 
diff --git a/fs/xfs/xfs_buf_item.c b/fs/xfs/xfs_buf_item.c
index e97aea447247..098cbef34f8a 100644
--- a/fs/xfs/xfs_buf_item.c
+++ b/fs/xfs/xfs_buf_item.c
@@ -1051,6 +1051,7 @@ xfs_buf_do_callbacks(
 	}
 }
 
+#ifndef __GENKSYMS__
 /*
  * Invoke the error state callback for each log item affected by the failed I/O.
  *
@@ -1075,6 +1076,7 @@ xfs_buf_do_callbacks_fail(
 	}
 	spin_unlock(&ailp->xa_lock);
 }
+#endif
 
 static bool
 xfs_buf_iodone_callback_error(
@@ -1084,7 +1086,10 @@ xfs_buf_iodone_callback_error(
 	struct xfs_mount	*mp = lip->li_mountp;
 	static ulong		lasttime;
 	static xfs_buftarg_t	*lasttarg;
+#ifndef __GENKSYMS__
 	struct xfs_error_cfg	*cfg;
+#endif
+	bool			last_error_match = false;
 
 	/*
 	 * If we've already decided to shutdown the filesystem because of
@@ -1107,6 +1112,10 @@ xfs_buf_iodone_callback_error(
 	trace_xfs_buf_item_iodone_async(bp, _RET_IP_);
 	ASSERT(bp->b_iodone != NULL);
 
+#ifndef __GENKSYMS__
+	if (bp->b_last_error != bp->b_error)
+		last_error_match = true;
+#endif
 	/*
 	 * If the write was asynchronous then no one will be looking for the
 	 * error.  If this is the first failure of this type, clear the error
@@ -1115,18 +1124,21 @@ xfs_buf_iodone_callback_error(
 	 * up to behave correctly now for repeated failures.
 	 */
 	if (!(bp->b_flags & (XBF_STALE|XBF_WRITE_FAIL)) ||
-	     bp->b_last_error != bp->b_error) {
+	     last_error_match) {
 		bp->b_flags |= (XBF_WRITE | XBF_ASYNC |
 			        XBF_DONE | XBF_WRITE_FAIL);
+#ifndef __GENKSYMS__
 		bp->b_last_error = bp->b_error;
 		bp->b_retries = 0;
 		bp->b_first_retry_time = jiffies;
+#endif
 
 		xfs_buf_ioerror(bp, 0);
 		xfs_buf_submit(bp);
 		return true;
 	}
 
+#ifndef __GENKSYMS__
 	/*
 	 * Repeated failure on an async write. Take action according to the
 	 * error configuration we have been set up to use.
@@ -1149,16 +1161,19 @@ xfs_buf_iodone_callback_error(
 	 * the higher layers retry the buffer.
 	 */
 	xfs_buf_do_callbacks_fail(bp);
+#endif
 	xfs_buf_ioerror(bp, 0);
 	xfs_buf_relse(bp);
 	return true;
 
+#ifndef __GENKSYMS__
 	/*
 	 * Permanent error - we need to trigger a shutdown if we haven't already
 	 * to indicate that inconsistency will result from this action.
 	 */
 permanent_error:
 	xfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);
+#endif
 out_stale:
 	xfs_buf_stale(bp);
 	XFS_BUF_DONE(bp);
@@ -1185,12 +1200,14 @@ xfs_buf_iodone_callbacks(
 	if (bp->b_error && xfs_buf_iodone_callback_error(bp))
 		return;
 
+#ifndef __GENKSYMS__
 	/*
 	 * Successful IO or permanent error. Either way, we can clear the
 	 * retry state here in preparation for the next error that may occur.
 	 */
 	bp->b_last_error = 0;
 	bp->b_retries = 0;
+#endif
 
 	xfs_buf_do_callbacks(bp);
 	bp->b_fspriv = NULL;
@@ -1230,6 +1247,7 @@ xfs_buf_iodone(
 	xfs_buf_item_free(BUF_ITEM(lip));
 }
 
+#ifndef __GENKSYMS__
 /*
  * Requeue a failed buffer for writeback
  *
@@ -1257,3 +1275,4 @@ xfs_buf_resubmit_failed_buffers(
 	/* Add this buffer back to the delayed write list */
 	return xfs_buf_delwri_queue(bp, buffer_list);
 }
+#endif
diff --git a/fs/xfs/xfs_inode_item.c b/fs/xfs/xfs_inode_item.c
index a03d8908e2ec..fff68945c886 100644
--- a/fs/xfs/xfs_inode_item.c
+++ b/fs/xfs/xfs_inode_item.c
@@ -404,6 +404,7 @@ xfs_inode_item_unpin(
 		wake_up_bit(&ip->i_flags, __XFS_IPINNED_BIT);
 }
 
+#ifndef __GENKSYMS__
 /*
  * Callback used to mark a buffer with XFS_LI_FAILED when items in the buffer
  * have been failed during writeback
@@ -420,6 +421,7 @@ xfs_inode_item_error(
 	ASSERT(xfs_isiflocked(INODE_ITEM(lip)->ili_inode));
 	xfs_set_li_failed(lip, bp);
 }
+#endif
 
 STATIC uint
 xfs_inode_item_push(
@@ -428,10 +430,14 @@ xfs_inode_item_push(
 {
 	struct xfs_inode_log_item *iip = INODE_ITEM(lip);
 	struct xfs_inode	*ip = iip->ili_inode;
-	struct xfs_buf		*bp = lip->li_buf;
+	struct xfs_buf		*bp = NULL;
 	uint			rval = XFS_ITEM_SUCCESS;
 	int			error;
 
+#ifndef __GENKSYMS__
+	bp = lip->li_buf;
+#endif
+
 	if (xfs_ipincount(ip) > 0)
 		return XFS_ITEM_PINNED;
 
@@ -440,6 +446,7 @@ xfs_inode_item_push(
 	 * previously. Resubmit the buffer for IO.
 	 */
 	if (lip->li_flags & XFS_LI_FAILED) {
+#ifndef __GENKSYMS__
 		if (!xfs_buf_trylock(bp))
 			return XFS_ITEM_LOCKED;
 
@@ -447,6 +454,10 @@ xfs_inode_item_push(
 			rval = XFS_ITEM_FLUSHING;
 
 		xfs_buf_unlock(bp);
+#else
+		rval = XFS_ITEM_FLUSHING;
+#endif
+
 		return rval;
 	}
 
@@ -582,7 +593,9 @@ static const struct xfs_item_ops xfs_inode_item_ops = {
 	.iop_committed	= xfs_inode_item_committed,
 	.iop_push	= xfs_inode_item_push,
 	.iop_committing = xfs_inode_item_committing,
+#ifndef __GENKSYMS__
 	.iop_error	= xfs_inode_item_error
+#endif
 };
 
 
diff --git a/fs/xfs/xfs_mount.c b/fs/xfs/xfs_mount.c
index 7ce357d71c8f..3adb307a9792 100644
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@ -701,8 +701,10 @@ xfs_mountfs(
 
 	xfs_set_maxicount(mp);
 
+#ifndef __GENKSYMS__
 	/* enable fail_at_unmount as default */
 	mp->m_fail_unmount = 1;
+#endif
 
 	error = xfs_sysfs_init(&mp->m_kobj, &xfs_mp_ktype, NULL, mp->m_fsname);
 	if (error)
diff --git a/fs/xfs/xfs_mount.h b/fs/xfs/xfs_mount.h
index ac8945a20a0f..e3acf7088f3c 100644
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@ -156,9 +156,11 @@ typedef struct xfs_mount {
 	int64_t			m_low_space[XFS_LOWSP_MAX];
 						/* low free space thresholds */
 	struct xfs_kobj		m_kobj;
+#ifndef __GENKSYMS__
 	struct xfs_kobj		m_error_kobj;
 	struct xfs_kobj		m_error_meta_kobj;
 	struct xfs_error_cfg	m_error_cfg[XFS_ERR_CLASS_MAX][XFS_ERR_ERRNO_MAX];
+#endif
 	struct xstats		m_stats;	/* per-fs stats */
 
 	struct workqueue_struct *m_buf_workqueue;
@@ -180,7 +182,9 @@ typedef struct xfs_mount {
 	 */
 	__uint32_t		m_generation;
 
+#ifndef __GENKSYMS__
 	bool			m_fail_unmount;
+#endif
 	const char		*m_mtpt;
 } xfs_mount_t;
 
diff --git a/fs/xfs/xfs_sysfs.c b/fs/xfs/xfs_sysfs.c
index 723ef04d4733..aaae57b88116 100644
--- a/fs/xfs/xfs_sysfs.c
+++ b/fs/xfs/xfs_sysfs.c
@@ -273,6 +273,7 @@ struct kobj_type xfs_log_ktype = {
 	.default_attrs = xfs_log_attrs,
 };
 
+#ifndef __GENKSYMS__
 /*
  * Metadata IO error configuration
  *
@@ -560,3 +561,7 @@ xfs_error_get_cfg(
 
 	return cfg;
 }
+#else
+int xfs_error_sysfs_init(struct xfs_mount *mp) { return; }
+void xfs_error_sysfs_del(struct xfs_mount *mp) { return; }
+#endif /* __GENKSYMS__ */
diff --git a/fs/xfs/xfs_trans.h b/fs/xfs/xfs_trans.h
index d62727c7ef56..61beabe1d686 100644
--- a/fs/xfs/xfs_trans.h
+++ b/fs/xfs/xfs_trans.h
@@ -42,7 +42,9 @@ typedef struct xfs_log_item {
 	struct xfs_ail			*li_ailp;	/* ptr to AIL */
 	uint				li_type;	/* item type */
 	uint				li_flags;	/* misc flags */
+#ifndef __GENKSYMS__
 	struct xfs_buf			*li_buf;	/* real buffer pointer */
+#endif
 	struct xfs_log_item		*li_bio_list;	/* buffer item list */
 	void				(*li_cb)(struct xfs_buf *,
 						 struct xfs_log_item *);
@@ -74,7 +76,9 @@ struct xfs_item_ops {
 	void (*iop_unlock)(xfs_log_item_t *);
 	xfs_lsn_t (*iop_committed)(xfs_log_item_t *, xfs_lsn_t);
 	void (*iop_committing)(xfs_log_item_t *, xfs_lsn_t);
+#ifndef __GENKSYMS__
 	void (*iop_error)(xfs_log_item_t *, xfs_buf_t *);
+#endif
 };
 
 void	xfs_log_item_init(struct xfs_mount *mp, struct xfs_log_item *item,
diff --git a/fs/xfs/xfs_trans_priv.h b/fs/xfs/xfs_trans_priv.h
index b317a3644c00..842d85093be1 100644
--- a/fs/xfs/xfs_trans_priv.h
+++ b/fs/xfs/xfs_trans_priv.h
@@ -165,6 +165,7 @@ xfs_trans_ail_copy_lsn(
 }
 #endif
 
+#ifndef __GENKSYMS__
 static inline void
 xfs_clear_li_failed(
 	struct xfs_log_item	*lip)
@@ -180,7 +181,16 @@ xfs_clear_li_failed(
 		xfs_buf_rele(bp);
 	}
 }
+#else
+static inline void
+xfs_clear_li_failed(
+	struct xfs_log_item	*lip)
+{
+	return;
+}
+#endif
 
+#ifndef __GENKSYMS__
 static inline void
 xfs_set_li_failed(
 	struct xfs_log_item	*lip,
@@ -194,5 +204,14 @@ xfs_set_li_failed(
 		lip->li_buf = bp;
 	}
 }
+#else
+static inline void
+xfs_set_li_failed(
+	struct xfs_log_item	*lip,
+	struct xfs_buf		*bp)
+{
+	return;
+}
+#endif
 
 #endif	/* __XFS_TRANS_PRIV_H__ */
