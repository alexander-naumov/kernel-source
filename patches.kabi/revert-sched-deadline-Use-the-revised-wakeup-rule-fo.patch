From: Jiri Slaby <jslaby@suse.cz>
Date: Thu, 1 Feb 2018 10:07:43 +0100
Subject: Revert "sched/deadline: Use the revised wakeup rule for suspending
 constrained dl tasks"
Patch-mainline: never, kabi
References: kabi

This reverts commit 1d00e3d9b7ed8fbf6729b7c5a8aae9f2711d2655, upstream
commit 3effcb4247e74a51f5d8b775a1ee4abf87cc089a. It added "u64
dl_density" into struct sched_dl_entity which is embedded in struct
task_struct. This obviously broke kABI and I see no way out.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/sched.h   |  1 -
 kernel/sched/core.c     |  2 -
 kernel/sched/deadline.c | 98 ++++++-------------------------------------------
 3 files changed, 12 insertions(+), 89 deletions(-)

diff --git a/include/linux/sched.h b/include/linux/sched.h
index 90bea398e5e0..e887c8d6f395 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1313,7 +1313,6 @@ struct sched_dl_entity {
 	u64 dl_deadline;	/* relative deadline of each instance	*/
 	u64 dl_period;		/* separation of two instances (period) */
 	u64 dl_bw;		/* dl_runtime / dl_deadline		*/
-	u64 dl_density;		/* dl_runtime / dl_deadline		*/
 
 	/*
 	 * Actual scheduling parameters. Initialized with the values above,
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index e6d1173a2046..9d6b3d869592 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -2109,7 +2109,6 @@ void __dl_clear_params(struct task_struct *p)
 	dl_se->dl_period = 0;
 	dl_se->flags = 0;
 	dl_se->dl_bw = 0;
-	dl_se->dl_density = 0;
 
 	dl_se->dl_throttled = 0;
 	dl_se->dl_new = 1;
@@ -3648,7 +3647,6 @@ __setparam_dl(struct task_struct *p, const struct sched_attr *attr)
 	dl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;
 	dl_se->flags = attr->sched_flags;
 	dl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);
-	dl_se->dl_density = to_ratio(dl_se->dl_deadline, dl_se->dl_runtime);
 
 	/*
 	 * Changing the parameters of a task is 'tricky' and we're not doing
diff --git a/kernel/sched/deadline.c b/kernel/sched/deadline.c
index e12b0a4df891..6be2afd9bfd6 100644
--- a/kernel/sched/deadline.c
+++ b/kernel/sched/deadline.c
@@ -480,84 +480,13 @@ static bool dl_entity_overflow(struct sched_dl_entity *dl_se,
 }
 
 /*
- * Revised wakeup rule [1]: For self-suspending tasks, rather then
- * re-initializing task's runtime and deadline, the revised wakeup
- * rule adjusts the task's runtime to avoid the task to overrun its
- * density.
+ * When a -deadline entity is queued back on the runqueue, its runtime and
+ * deadline might need updating.
  *
- * Reasoning: a task may overrun the density if:
- *    runtime / (deadline - t) > dl_runtime / dl_deadline
- *
- * Therefore, runtime can be adjusted to:
- *     runtime = (dl_runtime / dl_deadline) * (deadline - t)
- *
- * In such way that runtime will be equal to the maximum density
- * the task can use without breaking any rule.
- *
- * [1] Luca Abeni, Giuseppe Lipari, and Juri Lelli. 2015. Constant
- * bandwidth server revisited. SIGBED Rev. 11, 4 (January 2015), 19-24.
- */
-static void
-update_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)
-{
-	u64 laxity = dl_se->deadline - rq_clock(rq);
-
-	/*
-	 * If the task has deadline < period, and the deadline is in the past,
-	 * it should already be throttled before this check.
-	 *
-	 * See update_dl_entity() comments for further details.
-	 */
-	WARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));
-
-	dl_se->runtime = (dl_se->dl_density * laxity) >> 20;
-}
-
-/*
- * Regarding the deadline, a task with implicit deadline has a relative
- * deadline == relative period. A task with constrained deadline has a
- * relative deadline <= relative period.
- *
- * We support constrained deadline tasks. However, there are some restrictions
- * applied only for tasks which do not have an implicit deadline. See
- * update_dl_entity() to know more about such restrictions.
- *
- * The dl_is_implicit() returns true if the task has an implicit deadline.
- */
-static inline bool dl_is_implicit(struct sched_dl_entity *dl_se)
-{
-	return dl_se->dl_deadline == dl_se->dl_period;
-}
-
-/*
- * When a deadline entity is placed in the runqueue, its runtime and deadline
- * might need to be updated. This is done by a CBS wake up rule. There are two
- * different rules: 1) the original CBS; and 2) the Revisited CBS.
- *
- * When the task is starting a new period, the Original CBS is used. In this
- * case, the runtime is replenished and a new absolute deadline is set.
- *
- * When a task is queued before the begin of the next period, using the
- * remaining runtime and deadline could make the entity to overflow, see
- * dl_entity_overflow() to find more about runtime overflow. When such case
- * is detected, the runtime and deadline need to be updated.
- *
- * If the task has an implicit deadline, i.e., deadline == period, the Original
- * CBS is applied. the runtime is replenished and a new absolute deadline is
- * set, as in the previous cases.
- *
- * However, the Original CBS does not work properly for tasks with
- * deadline < period, which are said to have a constrained deadline. By
- * applying the Original CBS, a constrained deadline task would be able to run
- * runtime/deadline in a period. With deadline < period, the task would
- * overrun the runtime/period allowed bandwidth, breaking the admission test.
- *
- * In order to prevent this misbehave, the Revisited CBS is used for
- * constrained deadline tasks when a runtime overflow is detected. In the
- * Revisited CBS, rather than replenishing & setting a new absolute deadline,
- * the remaining runtime of the task is reduced to avoid runtime overflow.
- * Please refer to the comments update_dl_revised_wakeup() function to find
- * more about the Revised CBS rule.
+ * The policy here is that we update the deadline of the entity only if:
+ *  - the current deadline is in the past,
+ *  - using the remaining runtime with the current deadline would make
+ *    the entity exceed its bandwidth.
  */
 static void update_dl_entity(struct sched_dl_entity *dl_se,
 			     struct sched_dl_entity *pi_se)
@@ -576,14 +505,6 @@ static void update_dl_entity(struct sched_dl_entity *dl_se,
 
 	if (dl_time_before(dl_se->deadline, rq_clock(rq)) ||
 	    dl_entity_overflow(dl_se, pi_se, rq_clock(rq))) {
-
-		if (unlikely(!dl_is_implicit(dl_se) &&
-			     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&
-			     !dl_se->dl_boosted)){
-			update_dl_revised_wakeup(dl_se, rq);
-			return;
-		}
-
 		dl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;
 		dl_se->runtime = pi_se->dl_runtime;
 	}
@@ -1070,6 +991,11 @@ static void dequeue_dl_entity(struct sched_dl_entity *dl_se)
 	__dequeue_dl_entity(dl_se);
 }
 
+static inline bool dl_is_constrained(struct sched_dl_entity *dl_se)
+{
+	return dl_se->dl_deadline < dl_se->dl_period;
+}
+
 static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)
 {
 	struct task_struct *pi_task = rt_mutex_get_top_task(p);
@@ -1101,7 +1027,7 @@ static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)
 	 * If that is the case, the task will be throttled and
 	 * the replenishment timer will be set to the next period.
 	 */
-	if (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))
+	if (!p->dl.dl_throttled && dl_is_constrained(&p->dl))
 		dl_check_constrained_dl(&p->dl);
 
 	/*
-- 
2.16.1

