From: Miroslav Benes <mbenes@suse.cz>
Subject: x86/kaiser: Use a per-CPU trampoline stack for kernel entry
Git-commit: 7f2590a110b837af5679d08fc25c6227c5a8c497
Patch-mainline: v4.15-rc5
References: bsc#1077560

Currently, entries from usermode use kernel thread stack of a running
task. Therefore the stack has to be mapped in a usermode part of CR3.
Introduce a small per-CPU trampoline stack in TSS for all IDT entries to
avoid that. The trampoline stack will be used to switch over to a proper
kernel stack once running in ring0.

Parts of code adapted from the upstream commit 7f2590a110b8
("x86/entry/64: Use a per-CPU trampoline stack for IDT entries").

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
---
 arch/x86/entry/entry_64.S        |  125 +++++++++++++++++++--------------------
 arch/x86/entry/entry_64_compat.S |   17 ++++-
 arch/x86/include/asm/kaiser.h    |    9 ++
 arch/x86/kernel/asm-offsets_64.c |    1 
 arch/x86/kernel/cpu/common.c     |    8 ++
 arch/x86/kernel/process_64.c     |    3 
 arch/x86/kernel/traps.c          |   21 +++---
 kernel/fork.c                    |    4 -
 8 files changed, 104 insertions(+), 84 deletions(-)

--- a/arch/x86/entry/entry_64.S
+++ b/arch/x86/entry/entry_64.S
@@ -227,6 +227,7 @@ entry_SYSCALL_64_fastpath:
 	DISABLE_IBRS
 
 	RESTORE_C_REGS_EXCEPT_RCX_R11
+	movq	RSP(%rsp), %rsp
 	/*
 	 * This opens a window where we have a user CR3, but are
 	 * running in the kernel.  This makes using the CS
@@ -234,8 +235,7 @@ entry_SYSCALL_64_fastpath:
 	 * switch CR3 in NMIs.  Normal interrupts are OK because
 	 * they are off here.
 	 */
-	SWITCH_USER_CR3
-	movq	RSP(%rsp), %rsp
+	SWITCH_USER_CR3_NO_STACK
 	/*
 	 * 64-bit SYSRET restores rip from rcx,
 	 * rflags from r11 (but RF and VM bits are forced to 0),
@@ -379,6 +379,7 @@ syscall_return_via_sysret:
 
 	/* rcx and r11 are already restored (see code above) */
 	RESTORE_C_REGS_EXCEPT_RCX_R11
+	movq	RSP(%rsp), %rsp
 	/*
 	 * This opens a window where we have a user CR3, but are
 	 * running in the kernel.  This makes using the CS
@@ -386,23 +387,13 @@ syscall_return_via_sysret:
 	 * switch CR3 in NMIs.  Normal interrupts are OK because
 	 * they are off here.
 	 */
-	SWITCH_USER_CR3
-	movq	RSP(%rsp), %rsp
+	SWITCH_USER_CR3_NO_STACK
 	USERGS_SYSRET64
 
 opportunistic_sysret_failed:
 	DISABLE_IBRS
 
-	/*
-	 * This opens a window where we have a user CR3, but are
-	 * running in the kernel.  This makes using the CS
-	 * register useless for telling whether or not we need to
-	 * switch CR3 in NMIs.  Normal interrupts are OK because
-	 * they are off here.
-	 */
-	SWITCH_USER_CR3
-	SWAPGS
-	jmp	restore_c_regs_and_iret
+	jmp tramp_restore_c_regs_and_iret
 END(entry_SYSCALL_64)
 
 
@@ -547,6 +538,26 @@ END(irq_entries_start)
 /* 0(%rsp): ~(interrupt number) */
 	.macro interrupt func
 	cld
+
+	testb	$3, CS-ORIG_RAX(%rsp)
+	jz	1f
+	SWAPGS
+
+	/* Coming from user mode. Switch to the thread stack. */
+	pushq	%rdi
+	/* Need to switch before accessing the thread stack. */
+	SWITCH_KERNEL_CR3
+	movq	%rsp, %rdi
+	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
+	pushq	SS-RDI(%rdi)		/* regs->ss */
+	pushq	RSP-RDI(%rdi)		/* regs->rsp */
+	pushq	EFLAGS-RDI(%rdi)	/* regs->eflags */
+	pushq	CS-RDI(%rdi)		/* regs->cs */
+	pushq	RIP-RDI(%rdi)		/* regs->ip */
+	pushq	ORIG_RAX-RDI(%rdi)	/* regs->orig_ax */
+	movq	(%rdi), %rdi
+
+1:
 	ALLOC_PT_GPREGS_ON_STACK
 	SAVE_C_REGS
 	SAVE_EXTRA_REGS
@@ -556,12 +567,6 @@ END(irq_entries_start)
 	testb	$3, CS(%rsp)
 	jz	1f
 
-	/*
-	 * IRQ from user mode.  Switch to kernel gsbase and inform context
-	 * tracking that we're in kernel mode.
-	 */
-	SWAPGS
-	SWITCH_KERNEL_CR3
 	ENABLE_IBRS
 
 	/*
@@ -620,10 +625,31 @@ GLOBAL(retint_user)
 	mov	%rsp,%rdi
 	call	prepare_exit_to_usermode
 	TRACE_IRQS_IRETQ
+
 	DISABLE_IBRS
+	/*
+	 * Returning from an interrupt to user space, currently on the kernel
+	 * task stack.  Switch to the trampoline stack and push the iret frame
+	 * to it.
+	 */
+GLOBAL(tramp_restore_regs_and_iret)
+	RESTORE_EXTRA_REGS
+tramp_restore_c_regs_and_iret:
+	RESTORE_C_REGS
+	REMOVE_PT_GPREGS_FROM_STACK 8
+	pushq %rax
+	movq %rsp, %rax
+	movq PER_CPU_VAR(cpu_tss + TSS_sp0), %rsp
+	pushq SS-ORIG_RAX(%rax)
+	pushq RSP-ORIG_RAX(%rax)
+	pushq EFLAGS-ORIG_RAX(%rax)
+	pushq CS-ORIG_RAX(%rax)
+	pushq RIP-ORIG_RAX(%rax)
+	movq (%rax), %rax
+
 	SWITCH_USER_CR3
 	SWAPGS
-	jmp	restore_regs_and_iret
+	INTERRUPT_RETURN
 
 /* Returning to kernel space */
 retint_kernel:
@@ -796,11 +822,12 @@ ENTRY(\sym)
 
 	ALLOC_PT_GPREGS_ON_STACK
 
-	.if \paranoid
-	.if \paranoid == 1
+	.if \paranoid < 2
 	testb	$3, CS(%rsp)			/* If coming from userspace, switch stacks */
 	jnz	1f
 	.endif
+
+	.if \paranoid
 	call	paranoid_entry
 	.else
 	call	error_entry
@@ -841,9 +868,9 @@ ENTRY(\sym)
 	jmp	error_exit
 	.endif
 
-	.if \paranoid == 1
+	.if \paranoid < 2
 	/*
-	 * Paranoid entry from userspace.  Switch stacks and treat it
+	 * Entry from userspace.  Switch stacks and treat it
 	 * as a normal entry.  This means that paranoid handlers
 	 * run in real process context if user_mode(regs).
 	 */
@@ -852,10 +879,6 @@ ENTRY(\sym)
 
 
 	movq	%rsp, %rdi			/* pt_regs pointer */
-	call	sync_regs
-	movq	%rax, %rsp			/* switch stack */
-
-	movq	%rsp, %rdi			/* pt_regs pointer */
 
 	.if \has_error_code
 	movq	ORIG_RAX(%rsp), %rsi		/* get error code */
@@ -1192,15 +1215,16 @@ ENTRY(error_entry)
 	 * from user mode due to an IRET fault.
 	 */
 	SWAPGS
-
 	ENABLE_IBRS
 
 .Lerror_entry_from_usermode_after_swapgs:
-	/*
-	 * We need to tell lockdep that IRQs are off.  We can't do this until
-	 * we fix gsbase, and we should do it before enter_from_user_mode
-	 * (which can take locks).
-	 */
+	/* Put us onto the real thread stack. */
+	popq    %r12                            /* save return addr in %12 */
+	movq    %rsp, %rdi                      /* arg0 = pt_regs pointer */
+	call    sync_regs
+	movq    %rax, %rsp                      /* switch stack */
+	pushq   %r12
+
 	TRACE_IRQS_OFF
 	CALL_enter_from_user_mode
 	ret
@@ -1345,11 +1369,10 @@ ENTRY(nmi)
 	 */
 
 	SWAPGS_UNSAFE_STACK
-	/*
-	 * percpu variables are mapped with user CR3, so no need
-	 * to switch CR3 here.
-	 */
 	cld
+
+	SWITCH_KERNEL_CR3
+
 	movq	%rsp, %rdx
 	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
 	pushq	5*8(%rdx)	/* pt_regs->ss */
@@ -1382,18 +1405,6 @@ ENTRY(nmi)
 
 	movq	%rsp, %rdi
 	movq	$-1, %rsi
-#ifdef CONFIG_PAGE_TABLE_ISOLATION
-	/* Unconditionally use kernel CR3 for do_nmi() */
-	/* %rax is saved above, so OK to clobber here */
-	ALTERNATIVE "jmp 2f", "movq %cr3, %rax", X86_FEATURE_KAISER
-	/* If PCID enabled, NOFLUSH now and NOFLUSH on return */
-	ALTERNATIVE "", "bts $63, %rax", X86_FEATURE_PCID
-	pushq	%rax
-	/* mask off "user" bit of pgd address and 12 PCID bits: */
-	andq	$(~(X86_CR3_PCID_ASID_MASK | KAISER_SHADOW_PGD_OFFSET)), %rax
-	movq	%rax, %cr3
-2:
-#endif
 
 	ENABLE_IBRS
 
@@ -1401,23 +1412,13 @@ ENTRY(nmi)
 
 	DISABLE_IBRS
 
-#ifdef CONFIG_PAGE_TABLE_ISOLATION
-	/*
-	 * Unconditionally restore CR3.  I know we return to
-	 * kernel code that needs user CR3, but do we ever return
-	 * to "user mode" where we need the kernel CR3?
-	 */
-	ALTERNATIVE "", "popq %rax; movq %rax, %cr3", X86_FEATURE_KAISER
-#endif
-
 	/*
 	 * Return back to user mode.  We must *not* do the normal exit
 	 * work, because we don't want to enable interrupts.  Do not
 	 * switch to user CR3: we might be going back to kernel code
 	 * that had a user CR3 set.
 	 */
-	SWAPGS
-	jmp	restore_c_regs_and_iret
+	jmp	tramp_restore_c_regs_and_iret
 
 .Lnmi_from_kernel:
 	/*
--- a/arch/x86/entry/entry_64_compat.S
+++ b/arch/x86/entry/entry_64_compat.S
@@ -220,7 +220,6 @@ ENTRY(entry_SYSCALL_compat)
 sysret32_from_system_call:
 	TRACE_IRQS_ON			/* User mode traces as IRQs on. */
 	DISABLE_IBRS
-	SWITCH_USER_CR3
 	movq	RBX(%rsp), %rbx		/* pt_regs->rbx */
 	movq	RBP(%rsp), %rbp		/* pt_regs->rbp */
 	movq	EFLAGS(%rsp), %r11	/* pt_regs->flags (in r11) */
@@ -251,6 +250,7 @@ sysret32_from_system_call:
 	xorq	%r9, %r9
 	xorq	%r10, %r10
 	movq	RSP-ORIG_RAX(%rsp), %rsp
+	SWITCH_USER_CR3_NO_STACK
         USERGS_SYSRET32
 END(entry_SYSCALL_compat)
 
@@ -293,6 +293,17 @@ ENTRY(entry_INT80_compat)
 	 */
 	movl	%eax, %eax
 
+	/* Coming from user mode. Switch to the thread stack. */
+	pushq	%rax
+	movq	%rsp, %rax
+	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
+	pushq	SS-ORIG_RAX(%rax)		/* regs->ss */
+	pushq	RSP-ORIG_RAX(%rax)		/* regs->rsp */
+	pushq	EFLAGS-ORIG_RAX(%rax)		/* regs->eflags */
+	pushq	CS-ORIG_RAX(%rax)		/* regs->cs */
+	pushq	RIP-ORIG_RAX(%rax)		/* regs->ip */
+	movq	(%rax), %rax
+
 	/* Construct struct pt_regs on stack (iret frame is already on stack) */
 	pushq	%rax			/* pt_regs->orig_ax */
 	pushq	%rdi			/* pt_regs->di */
@@ -329,9 +340,7 @@ ENTRY(entry_INT80_compat)
 	/* Go back to user mode. */
 	TRACE_IRQS_ON
 	DISABLE_IBRS
-	SWITCH_USER_CR3
-	SWAPGS
-	jmp	restore_regs_and_iret
+	jmp	tramp_restore_regs_and_iret
 END(entry_INT80_compat)
 
 	ALIGN
--- a/arch/x86/include/asm/kaiser.h
+++ b/arch/x86/include/asm/kaiser.h
@@ -79,6 +79,15 @@ movq PER_CPU_VAR(unsafe_stack_register_b
 8:
 .endm
 
+.macro SWITCH_USER_CR3_NO_STACK
+ALTERNATIVE "jmp 8f", \
+	__stringify(movq %rax, PER_CPU_VAR(unsafe_stack_register_backup)), \
+	X86_FEATURE_KAISER
+_SWITCH_TO_USER_CR3 %rax %al
+movq PER_CPU_VAR(unsafe_stack_register_backup), %rax
+8:
+.endm
+
 #else /* CONFIG_PAGE_TABLE_ISOLATION */
 
 .macro SWITCH_KERNEL_CR3
--- a/arch/x86/kernel/asm-offsets_64.c
+++ b/arch/x86/kernel/asm-offsets_64.c
@@ -62,6 +62,7 @@ int main(void)
 	OFFSET(TSS_ist, tss_struct, x86_tss.ist);
 	OFFSET(TSS_sp0, tss_struct, x86_tss.sp0);
 	OFFSET(TSS_sp1, tss_struct, x86_tss.sp1);
+	DEFINE(TSS_stack_size, sizeof(cpu_tss.SYSENTER_stack));
 	BLANK();
 
 	DEFINE(__NR_syscall_max, sizeof(syscalls_64) - 1);
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -1508,7 +1508,13 @@ void cpu_init(void)
 	BUG_ON(me->mm);
 	enter_lazy_tlb(&init_mm, me);
 
-	load_sp0(t, &current->thread);
+	/*
+	 * Initialize the TSS.  sp0 points to the entry trampoline stack
+	 * regardless of what task is running.
+	 */
+	t->x86_tss.sp0 = (unsigned long)t + offsetofend(struct tss_struct,
+		SYSENTER_stack);
+
 	set_tss_desc(cpu, t);
 	load_TR_desc();
 	load_mm_ldt(&init_mm);
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -404,9 +404,6 @@ __switch_to(struct task_struct *prev_p,
 	this_cpu_write(cpu_current_top_of_stack,
 		(unsigned long)task_stack_page(next_p) + THREAD_SIZE);
 
-	/* Reload esp0 and ss1.  This changes current_thread_info(). */
-	load_sp0(tss, next);
-
 	/*
 	 * Now maybe reload the debug registers and handle I/O bitmaps
 	 */
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -528,14 +528,15 @@ NOKPROBE_SYMBOL(do_int3);
 
 #ifdef CONFIG_X86_64
 /*
- * Help handler running on IST stack to switch off the IST stack if the
- * interrupted code was in user mode. The actual stack switch is done in
- * entry_64.S
+ * Help handler running on a per-cpu (IST or entry trampoline) stack
+ * to switch to the normal thread stack if the interrupted code was in
+ * user mode. The actual stack switch is done in entry_64.S
  */
 asmlinkage __visible notrace struct pt_regs *sync_regs(struct pt_regs *eregs)
 {
-	struct pt_regs *regs = task_pt_regs(current);
-	*regs = *eregs;
+	struct pt_regs *regs = (struct pt_regs *)this_cpu_read(cpu_current_top_of_stack) - 1;
+	if (regs != eregs)
+		*regs = *eregs;
 	return regs;
 }
 NOKPROBE_SYMBOL(sync_regs);
@@ -551,13 +552,13 @@ struct bad_iret_stack *fixup_bad_iret(st
 	/*
 	 * This is called from entry_64.S early in handling a fault
 	 * caused by a bad iret to user mode.  To handle the fault
-	 * correctly, we want move our stack frame to task_pt_regs
-	 * and we want to pretend that the exception came from the
-	 * iret target.
+	 * correctly, we want to move our stack frame to where it would
+	 * be had we entered directly on the entry stack (rather than
+	 * just below the IRET frame) and we want to pretend that the
+	 * exception came from the IRET target.
 	 */
 	struct bad_iret_stack *new_stack =
-		container_of(task_pt_regs(current),
-			     struct bad_iret_stack, regs);
+		(struct bad_iret_stack *)this_cpu_read(cpu_tss.x86_tss.sp0) - 1;
 
 	/* Copy the IRET target to the new stack. */
 	memmove(&new_stack->regs.ip, (void *)s->regs.sp, 5*8);
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -170,7 +170,6 @@ static struct thread_info *alloc_thread_
 
 static inline void free_thread_info(struct thread_info *ti)
 {
-	kaiser_unmap_thread_stack(ti);
 	free_kmem_pages((unsigned long)ti, THREAD_SIZE_ORDER);
 }
 # else
@@ -355,9 +354,6 @@ static struct task_struct *dup_task_stru
 
 	tsk->stack = ti;
 
-	err = kaiser_map_thread_stack(tsk->stack);
-	if (err)
-		goto free_ti;
 #ifdef CONFIG_SECCOMP
 	/*
 	 * We must handle setting up seccomp filters once we're under
