From: Hannes Reinecke <hare@suse.de>
Date: Mon, 26 Feb 2018 13:10:21 +0100
Patch-mainline: Not yet, submission by hare outstanding
Subject: storvsc: do not schedule work elements during host reset
References: bsc#1070536, bsc#1057734

When host reset is active we're already running from a workqueue
context, _and_ we rescan the bus anyway.
So there's no need to schedule anything from individual workqueue
elements; we can as well do everything in-line and be sure that
we don't have outstanding workqueue elements after host reset
finished.

Signed-off-by: Hannes Reinecke <hare@suse.com>
Acked-by: <ohering@suse.de>
---
 drivers/scsi/storvsc_drv.c | 33 +++++++++++++++++++++++++++------
 1 file changed, 27 insertions(+), 6 deletions(-)

diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c
index c42d33d4cc77..7ac9bbfe73e9 100644
--- a/drivers/scsi/storvsc_drv.c
+++ b/drivers/scsi/storvsc_drv.c
@@ -538,9 +538,19 @@ static void storvsc_host_scan(struct work_struct *work)
 	 * scan the host. Thus we are forced to discover the LUNs that
 	 * may have been removed this way.
 	 */
+restart:
 	mutex_lock(&host->scan_mutex);
-	shost_for_each_device(sdev, host)
-		scsi_test_unit_ready(sdev, 1, 1, NULL);
+	shost_for_each_device(sdev, host) {
+		int retval;
+
+		retval = scsi_test_unit_ready(sdev, 1, 1, NULL);
+		if (host_byte(retval) == DID_NO_CONNECT) {
+			mutex_unlock(&host->scan_mutex);
+			scsi_remove_device(sdev);
+			scsi_device_put(sdev);
+			goto restart;
+		}
+	}
 	mutex_unlock(&host->scan_mutex);
 	/*
 	 * Now scan the host to discover LUNs that may have been added.
@@ -924,6 +934,9 @@ static void storvsc_handle_error(struct vmscsi_request *vm_srb,
 				struct Scsi_Host *host,
 				u8 asc, u8 ascq)
 {
+	struct hv_host_device *host_dev = shost_priv(host);
+	struct hv_device *device = host_dev->dev;
+	struct storvsc_device *stor_device = get_out_stor_device(device);
 	struct storvsc_scan_work *wrk;
 	void (*process_err_fn)(struct work_struct *work);
 	bool do_work = false;
@@ -960,14 +973,22 @@ static void storvsc_handle_error(struct vmscsi_request *vm_srb,
 		break;
 	case SRB_STATUS_INVALID_LUN:
 		set_host_byte(scmnd, DID_NO_CONNECT);
-		do_work = true;
-		process_err_fn = storvsc_remove_lun;
+		if (!stor_device->host_reset) {
+			do_work = true;
+			process_err_fn = storvsc_remove_lun;
+		} else
+			set_host_byte(scmnd, DID_NO_CONNECT);
 		break;
 	case SRB_STATUS_ABORTED:
 		if (vm_srb->srb_status & SRB_STATUS_AUTOSENSE_VALID &&
 		    (asc == 0x2a) && (ascq == 0x9)) {
-			do_work = true;
-			process_err_fn = storvsc_device_scan;
+			/*
+			 * No need to scan if we're resetting
+			 */
+			if (!stor_device->host_reset) {
+				do_work = true;
+				process_err_fn = storvsc_device_scan;
+			}
 			/*
 			 * Retry the I/O that trigerred this.
 			 */
-- 
2.12.3

